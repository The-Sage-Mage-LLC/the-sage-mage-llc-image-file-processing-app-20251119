# the-sage-mage-llc-image-file-processing-app-20251119
The Sage Mage LLC Image File Processing Utility App 2025-11-19 Public Repo

Let us consider this first section as Part 1, and my intent is that this be a command-line-style app/utility; however, I am open to your recommendations and suggestions.
I need an image file processing application. The intent is to utilize this application for both personal home family photo album images and commercially available images for sale on e-commerce websites.
This project, thread, chat has the ID/label: "Image Processing App 20251119".
The high-level requirements are as follows. I need complete grammar and spell checking on all output data across the board. I need all output data formatted in proper English sentence structure, including capitalization as appropriate. I need all output CSV files to have an initial/first column containing an application-generated primary key. I need all the output CSV files to have an ending/final column containing the datetime stamp of data acquisition/data row creation.
The application executable accepts a parameter on the command line by name, not by position, which contains a comma-delimited string of Windows-style, i.e., backslash, path names that the application will use as the 'source roots'. These are the directories where the application will start scanning for image files. This is a required parameter. There is no default value for this parameter. Minimum quantity of required paths = 1. Maximum number of paths accepted = 10. The application will validate this input for format and syntax, plus that each path supplied truly exists. If the path does not exist, this application will not create it. If there are errors or exceptions, the application will send these to the Console as Warning-level messages and to the log file as Warning-level messages. This will not be a fatal error and will not halt processing. If a path does not exist, then the application will skip that path.
The application executable accepts a parameter on the command line by name, not by position, which contains a comma-delimited string of Windows-style, i.e., backslash, path names that the application uses as the 'output roots'. These are the directories where the application will store the images for post-processing. This is a required parameter. There is no default value for this parameter. Minimum quantity of required paths = 1. Maximum number of paths accepted = 1. The application will validate this input for format and syntax, plus that each path supplied truly exists. If the path does not exist, this application will create a new path. If there are errors or exceptions, the application will send these to the Console as Warning-level messages and to the log file as Warning-level messages. This will not be a fatal error and will not halt processing. If a path does not exist, then the application will create that path and log the action.
The application executable accepts a parameter on the command line by name, not by position, that contains a comma-delimited string of Windows-style, i.e., backslash, path names that will be used as the "admin output" for the functionality to store the CSV files, log files, and any other non-image files the application generates during processing. This is a required parameter. There is no default value for this parameter. Minimum quantity of required paths = 1. Maximum number of paths accepted = 1. The application will validate this input for format and syntax, plus that each path supplied truly exists. If the path does not exist, this application will create a new path. If there are errors or exceptions, the application will send these to the Console as Warning-level messages and to the log file as Warning-level messages. This will not be a fatal error and will not halt processing. If a path does not exist, then the application will create that path and log the action.
The application executable accepts a parameter on the command line by name, not by position, that contains an integer number as a menu item, which I call out in detail in subsequent paragraphs as the 'processing functionality option' for the application to understand which image file processing functionality the user wants the application to execute, as detailed in subsequent paragraphs. This is a required parameter. The default value for this parameter = 1. The value of '1' is equivalent to executing all or the entire suite of functionality. Minimum quantity of required integers = 1. Maximum number of integers accepted = 1. The application will validate this input for format and syntax. If the integer (menu selection) is invalid or does not exist, then the application logs this information, and the application halts and closes gracefully. If there are errors or exceptions, such as the application or system not finding a file or a directory not accessible to the application or system, the application sends these to the Console as Warning-level messages and to the log file as Warning-level messages. This will not be a fatal error and will not halt processing unless the application cannot find the integer/menu item within the application.
Beginning at the source root(s), the application will recursively scan the directory and all subdirectories for all image files.
Menu Item 1 [default]: Execute all functionality as detailed below.
Menu Item 2: I need all the image files within the source root(s) folder assessed and evaluated for focus quality, sharpness, and blurriness. I need the application to identify images that are dramatically, human-noticeably blurry to a great degree. Minimally, this functionality requires one AI image processing model, but I prefer more varied models without going overboard. Additionally, the application will give greater weight to the center/middle area of the image than the peripheral areas, as this is common in photography to focus on the center/main image, and let the stereoscopic and 3D depth dimension be fuzzy. Utilizing the best option(s) and best practices, assess, evaluate, and extract from each image file the necessary data to perform the calculations and statistical analysis, then record everything in a CSV file with one row for each image file and columns/fields for each model, calculation, and decision. Then aggregate and synthesize all the separate models/decisions into a single Pass/Fail or Blurry TRUE/FALSE field/column. Store all the data in a CSV file in the specified admin output folder location. You will normalize and make consistent all the fields/columns in the file. Add an initial/first field/column and generate a Sequence Number or Primary Key-like integer for the application to populate that field with. If no data is available for a specific image file and field, then leave that cell empty/blank. The CSV output file naming convention is: "All_Image_Files_Focus_" & suffixed with the current local datetime stamp in the format: "yyyy-mm-dd_HH-mm-ss" with the time in 24-hour time format & then complete the name with the usual file extension. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file. Lastly, the application should move these blurry image files, not copy but move, to a different/new top-level folder. While the application maintains and creates, as necessary, the original folder structure, the top-level folder should be "IMGOrig-Blurry,” and the application should locate/find/build at the same level and on the same drive as the source root. The application renames all blurry image files to prepend "BLUR_ORIG_" to the beginning of the existing file name, and the remainder of the existing file name remains.
Menu Item 3: Extract all image file properties, attributes, security descriptors, EXIF metadata, and other metadata. Store all the data in a CSV file in the specified admin output folder location. You will normalize and make consistent all the fields/columns in the file. Add an initial/first field/column and generate a Sequence Number or Primary Key-like integer for the application to populate that field with. If no data is available for a specific image file and field, then leave that cell empty/blank. The application groups all date fields/columns together and sequences them one after the other. Dates are in the ISO standard format. Times are in 24-hour and ISO standard format. Times, when there is an option or choice, should all be local time based upon the image GPS data. The application outputs GPS data in a minimum of two different formats: DMS format and decimal format. I need the application to extract/calculate additional data fields and store this extra data, too: 1) Current image orientation: Portrait, Landscape, or Square, 2) the image's Aspect Ratio common/standard/nominal name/label, 3) the best/minimum/earliest datetime out of all the datetime fields to represent the actual image capture datetime, 4) the meteorological season of the image capture datetime, 5) the astronomical season of the image capture datetime, 6) the calendar quarter of the image capture datetime, 7) the standard time of day moniker/label for the time of day of the image capture datetime, 8) the US/European/English Astrological sign/house under which the image capture datetime falls, 9) the common/standard decade label/moniker for the nominal decade under which the image capture datetime falls, and 10) the Chinese Astrological Year of the xxx, under which the image capture datetime falls. Since the output file is a CSV file, the application converts any commas within the data that it extracts to semicolons. The application needs to strip out any line breaks, new lines, and CRLFs embedded within the data so that the application can store and present the data as single rows/lines within the CSV file. The CSV output file naming convention is: "All_Image_Files_Metadata_" & suffixed with the current local datetime stamp in the format: "yyyy-mm-dd_HH-mm-ss" with the time in 24-hour time format & then complete the name with the usual file extension. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file.
Menu Item 4: Utilizing the best option(s) and best practices, assess, evaluate, and extract from each image file a primary Caption, two alternate Captions, a primary verbose Description, two alternate verbose Descriptions, a minimum of one keyword to a maximum of 25 keywords, a minimum of one tag/hashtag to a maximum of 25 tags/hashtags, and an Alt Text blurb meeting the Alt Test specifications. Minimally, this functionality requires one AI image processing model, but I prefer more varied models without going overboard. Store all the data in a CSV file in the specified admin output folder location. You will normalize and make consistent all the fields/columns in the file. Add an initial/first field/column and generate a Sequence Number or Primary Key-like integer for the application to populate that field with. If no data is available for a specific image file and field, then leave that cell empty/blank. The application groups all date fields/columns together and sequences them one after the other. Dates are in the ISO standard format. Times are in 24-hour and ISO standard format. Times, when there is an option or choice, should all be local time based upon the image GPS data. GPS or location data should be in a human-readable form. Since the output file is a CSV file, the application will convert any commas within the data that it extracts or generates into semicolons. The application needs to strip out any line breaks, new lines, and CRLFs embedded within the data so that the application can store and present the data as single rows/lines within the CSV file. The CSV output file naming convention is: "All_Image_Files_Captions_" & suffixed with the current local datetime stamp in the format: "yyyy-mm-dd_HH-mm-ss" with the time in 24-hour time format & then complete the name with the usual file extension. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file. I need the application to generate additional column(s) and additional data for the GPS location data in a human-readable English language format. The location data should minimally include: 1) N-S hemisphere, 2) E-W hemisphere, 3) Continent, 4) Country, 5) Region, where available, 6) State or Province, 7) City or District, 8) Local Region, District, or Neighborhood, where available, and 9) ISO tags/designators if available for each of the preceding pieces of data.
Menu Item 5: Utilizing the best option(s) and best practices, assess, evaluate, and extract from each image file the predominant/dominant color(s); a total of four colors. For each majority color list: 1) The RGB values and HEX value for what was detected/calculated/determined, 2) list the percentage within the image, 3) list the HSV-A values for the same, 4) the nearest matching color with an English language human-readable name, 5) the source of that name, 6) if doable, the CMYK values, 7) if doable, any ISO color name, if one exists, and 8) any other global/international/standard color names/labels. Minimally, this functionality requires one AI image processing model, but I prefer more varied models without going overboard. Store all the data in a CSV file in the specified admin output folder location. You will normalize and make consistent all the fields/columns in the file. Add an initial/first field/column and generate a Sequence Number or Primary Key-like integer for the application to populate that field with. If no data is available for a specific image file and field, then leave that cell empty/blank. Since the output file is a CSV file, the application will convert any commas within the data that it extracts or generates into semicolons. The application needs to strip out any line breaks, new lines, and CRLFs embedded within the data so that the application can store and present the data as single rows/lines within the CSV file. The CSV output file naming convention is: "All_Image_Files_Colors_" & suffixed with the current local datetime stamp in the format: "yyyy-mm-dd_HH-mm-ss" with the time in 24-hour time format & then complete the name with the usual file extension. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file.
Menu item 6: I need the application to save a copy of all original image files (which I anticipate are all in color) without any processing to the output root location under a folder with the name "CLR_ORIG" and the application maintains the source root folder structure under that top-level folder. The application renames all image files to prepend "CLR_ORIG_" to the beginning of the existing file name, and the remainder of the existing file name remains. If a folder does not exist, then the application creates that folder. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file.
Menu Item 7: I need the application to modify and transform a copy of all original image files (which I anticipate are all in color) into Black and White (grayscale) and then save to the output root location under a folder with the name "BWG_ORIG" and the application maintains the source root folder structure under that top-level folder. The application renames all image files to prepend "BWG_ORIG_" to the beginning of the existing file name, and the remainder of the existing file name remains. If a folder does not exist, then the application creates that folder. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file.
Menu Item 8: I need the application to modify and transform a copy of all original image files (which I anticipate are all in color) into Sepia-toned and then save to the output root location under a folder with the name "SEP_ORIG" and the application maintains the source root folder structure under that top-level folder. The application renames all image files to prepend "SEP_ORIG_" to the beginning of the existing file name, and the remainder of the existing file name remains. If a folder does not exist, then the application creates that folder. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file.
Menu Item 9: I need the application to modify and transform a copy of all original image files (which I anticipate are all in color) into a Pencil Sketch utilizing a broad pencil tip, a large radius for processing, high clarity, low blurring, and medium strength for processing, and then save to the output root location under a folder with the name "PSK_ORIG" and the application maintains the source root folder structure under that top-level folder. The application renames all image files to prepend "PSK_ORIG_" to the beginning of the existing file name, and the remainder of the existing file name remains. If a folder does not exist, then the application creates that folder. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file.
Menu Item 10: I need the application to modify and transform a copy of all original image files (which I anticipate are all in color) into a strong outline-type image suitable for inclusion in a coloring book. You need to research and attempt to find some reasonable specifications for coloring book images, and apply those optimal and best practice coloring book settings/configs as internal defaults that will not generally require user modification, and then save the transformed image to the output root location under a folder with the name "BK_Coloring" and the application maintains the source root folder structure under that top-level folder. The application renames all image files to prepend "BK_Coloring_" to the beginning of the existing file name, and the remainder of the existing file name remains. If a folder does not exist, then the application creates that folder. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file.
Menu Item 11: I need the application to modify and transform a copy of all original image files (which I anticipate are all in color) into a connect-the-dots-style image suitable for inclusion in a connect-the-dots activity book. You need to research and attempt to find some reasonable specifications for connect-the-dots book images, and apply those optimal and best practice connect-the-dots book settings/configs as internal defaults that will not generally require user modification, and then save the transformed image to the output root location under a folder with the name "BK_CTD" and the application maintains the source root folder structure under that top-level folder. The application renames all image files to prepend "BK_CTD_" to the beginning of the existing file name, and the remainder of the existing file name remains. If a folder does not exist, then the application creates that folder. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file. You need to implement additional settings for this functionality that the user can tweak. The application will not integrate these into the command line. The application will store these in a settings file with the application. The additional settings are at a minimum: 1) Maximum Dots Allowed Per Image, 2) Minimum Distance Between Dots, 3) Minimum Distance Between Dots UOM, 4) Maximum Distance Between Dots, 5) Maximum Distance Between Dots UOM, 6) Maximum Dot Size, 7) Maximum Dot Size UOM, 8) Minimum Dot Size, and 9) Minimum Dot Size UOM. You need to research and perform statistical analysis for the optimal values to set these to initially, and set the initial values accordingly.
Menu Item 12: I need the application to modify and transform a copy of all original image files (which I anticipate are all in color) into a color-by-numbers-style image suitable for inclusion in a color-by-numbers activity book. You need to research and attempt to find some reasonable specifications for color-by-numbers book images, and apply those optimal and best practice color-by-numbers book settings/configs as internal defaults that will not generally require user modification, and then save the transformed image to the output root location under a folder with the name "BK_CBN" and the application maintains the source root folder structure under that top-level folder. The application renames all image files to prepend "BK_CBN_" to the beginning of the existing file name, and the remainder of the existing file name remains. If a folder does not exist, then the application creates that folder. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file. You need to implement additional settings for this functionality that the user can tweak. The application will not integrate these into the command line. The application will store these in a settings file with the application. The additional settings are at a minimum: 1) Maximum Distinct Colors Allowed Per Image, 2) Minimum Distance Between Distinct Color Groupings, 3) Maximum Distance Between Distinct Color Groupings, and 4) Minimum Area Size for Distinct Color Groupings. In real life, as one example, there may be hundreds of shades/hues of what someone may call "Orange" color, but I do not need each shade called out and numbered for this implementation. I need similar shades/hues grouped into one nominal color and given a single number. Additionally, you need to implement some amount of normalization/smoothing/blurring so that an area that is a distinct color, but the size of the area is below some threshold, then it does not get called out separately, but gets engulfed/consumed by the more dominant/surrounding color. You need to research and perform statistical analysis for the optimal values to set these configs initially, and set the initial values accordingly. Then, the resulting image transformation should have the colors removed and numbers overlayed, and maintain a light outline of the entire image.
Across all processing, the application needs to send "still processing" or "still alive" info-level messages to the console and to the log file with indications of progress and status.
Moreover, I need the application to be self-aware and self-monitoring during processing operations. I need the application to take samples and perform statistical analysis of what it is producing for output. Check image files that have undergone processing or transformation, perform minimal QA/QC checks, quick checks, and confirm actual against statistically expected results, i.e., output file size: smaller than anticipated or larger than expected, processing/transformation execution time/duration: faster than expected or slower than anticipated, empty or near empty files, compare hash values for original file against processed file to look for duplicate files – which should not be the case, and other checks/metrics you can think of.
Let us consider this second section as Part 2, and my intent is that this be a Windows-GUI-style app/utility front-end (wrapper) for what you created above in Part 1; however, I am open to your recommendations and suggestions.
I intend the application to only present, display, and utilize the GUI window Maximized and optimized for my current large-format, external monitor, or bigger.
My current large-format, external monitor display/graphics specifications are:
Samsung Smart Monitor
Model Code: LS32CM502EKXKR
Display Size: 32in (81.3cm)
Resolution: 1920px X 1080px Full HD
Aspect Ratio: 16:9
My suggestions, thoughts, and intent for window layout, format, look, feel, features, and functionality are, at a minimum and subject to any recommendations or suggestions you may provide:
The maximized window has a left-hand frame/section/area we will label as “Frame A” and is as close as you can implement to 50% of the available width (approximately 16in) by 100% of the available height (approximately 18in). A right-hand frame/section/area we will label as “Frame B” and is as close as you can implement to 50% of the available width (approximately 16in) by 100% of the available height (approximately 18in).
Within “Frame A,” the application implements standard, or close to standard, Windows File Explorer functionality. I will copy/paste, type by hand, or drill down and select the “Source” or Copy From folder. I intend to choose my source directory containing all my image files. The application will offer me two sorting options: A) Sort by Name ASC or B) Sort by Created Date DESC. The application will offer me two viewing options: 1) View large icons or 2) View details. The application needs to assess and evaluate each image file in the list and perform a check and count of the total quantity of EXIF, or other, metadata fields that are NOT empty/blank quickly and briefly. I do not require a total count. The cutoff is twenty-five. The condition is based on twenty-five or more fields with data or fewer than twenty-five fields with data. If twenty-five or more fields have data, then that file in the Explorer-style list/frame displays a green checkmark on a black background to the left of the file name and separated from the file name by a space/column/tab/something. If fewer than twenty-five fields have data, then that file in the Explorer-style list/frame displays a red X on a black background to the left of the file name and separated from the file name by a space/column/tab/something. I intend to quickly, eyeballing, differentiate image files in the list with or without metadata. At or near the top of the Explorer-style list/frame, the application will display a) a Total File Count, b) a Count of JPG/JPEG files, and c) a Count of PNG files. I intend to copy files from this Explorer-style list/frame Source folder by dragging and dropping. The application will implement standard single and multi-select functionality. The app will display two columns in the list: 1) “File Name” and 2) “Created Date”.
Within “Frame B,” the available 18in of vertical space is divided as follows: a) Row 1 - as close as you can implement to 7% of the available height (approximately 1.26in) by 100% of Frame B’s width (approximately 16in); b) Row 2 - as close as you can implement to 14% of the available height (approximately 2.52in) by 100% of Frame B’s width (approximately 16in); c) Row 3 - as close as you can implement to 14% of the available height (approximately 2.52in) by 100% of Frame B’s width (approximately 16in); and d) Row 4 - as close as you can implement to 7% of the available height (approximately 1.26in) by 100% of Frame B’s width (approximately 16in); and e) Rows 5, 6, 7, and 8 – each row as close as you can implement to 14% of the available height (approximately 2.52in) by 100% of Frame B’s width (approximately 16in).
Frame B, Row 1: Contains a row/horizontal list of seven (7) checkboxes from left to right with defaults of unchecked/off. Upon the user newly opening/executing this application, the application sets/resets all checkboxes to the defaults. These checkboxes control which image processing functionality executes in the follow-on workflows. These checkboxes support single or multiple selection options.
The checkbox requirements and specifications are as follows:
Checkbox 1 –
This checkbox designates that the user needs all the remaining six (6) functionalities to execute for the follow-on workflows.
I.e., command-line-style Part 1 menu item 7, modify and transform a copy of the original image file into Black and White (grayscale); command-line-style Part 1 menu item 8, alter and transform a copy of the original image file  into Sepia-toned; command-line-style Part 1 menu item 9, modify and transform a copy of the original image file into a Pencil Sketch utilizing a broad pencil tip, a large radius for processing, high clarity, low blurring, and medium strength for processing; command-line-style Part 1 menu item 10, modify and transform a copy of the original image files into a strong outline-type image suitable for inclusion in a coloring book; command-line-style Part 1 menu item 11, modify and transform a copy of the original image file into a connect-the-dots-style image ideal for inclusion in a connect-the-dots activity book; and command-line-style Part 1 menu item 12, modify and transform a copy of the original image file into a color-by-numbers-style image suitable for inclusion in a color-by-numbers activity book.
Upon the user checking this checkbox, the application will automatically check all six (6) remaining checkboxes and leave this checkbox checked.
Upon the user unchecking this checkbox, the application will automatically clear all six (6) remaining checkboxes and leave this checkbox unchecked.
If, after the user checks this box, resulting in the application automatically checking the remaining checkboxes, the user unchecks one or more of the other six (6) checkboxes, then the application will automatically clear this checkbox.
If, after the user leaves this checkbox unchecked, the user manually checks all the remaining six (6) checkboxes, then the application will automatically checkmark this checkbox. Checkbox label = “All” and the hover tooltip = “All six menu items.”
Checkbox 2 –
This checkbox designates that the user needs command-line-style Part 1 menu item 7, modify and transform a copy of the original image file into Black and White (grayscale) to execute for the follow-on workflows.
If, after the user checks this box, this results in the system showing all six (6) checkboxes as checked (not the “All” checkbox), then the application will automatically checkmark the “All” checkbox.
If the user unchecks this box and the user previously selected the “All” checkbox, then the application will automatically unselect the “All” checkbox.
Checkbox label = “BWG” and the hover tooltip = “Black and White (grayscale).”
Checkbox 3 –
This checkbox designates that the user needs command-line-style Part 1 menu item 8, modify and transform a copy of the original image file into Sepia-toned to execute for the follow-on workflows.
If, after the user checks this box and the user previously selected the “All” checkbox, then the application will automatically checkmark the “All” checkbox.
If the user unchecks this box and the user previously selected the “All” checkbox, then the application will automatically unselect the “All” checkbox.
Checkbox label = “SEP” and the hover tooltip = “Sepia-toned.”
Checkbox 4 –
This checkbox designates that the user needs command-line-style Part 1 menu item 9, modify and transform a copy of the original image file into a Pencil Sketch utilizing a broad pencil tip, a large radius for processing, high clarity, low blurring, and medium strength for processing to execute for the follow-on workflows.
If, after the user checks this box and the user previously selected the “All” checkbox, then the application will automatically checkmark the “All” checkbox.
If the user unchecks this box and the user previously selected the “All” checkbox, then the application will automatically unselect the “All” checkbox.
Checkbox label = “PSK” and the hover tooltip = “Pencil Sketch.”
Checkbox 5 –
This checkbox designates that the user needs command-line-style Part 1 menu item 10, modify and transform a copy of the original image files into a strong outline-type image suitable for inclusion in a coloring book to execute for the follow-on workflows.
If, after the user checks this box and the user previously selected the “All” checkbox, then the application will automatically checkmark the “All” checkbox.
If the user unchecks this box and the user previously selected the “All” checkbox, then the application will automatically unselect the “All” checkbox.
Checkbox label = “BK_CLR” and the hover tooltip = “Coloring book.”
Checkbox 6 –
This checkbox designates that the user needs command-line-style Part 1 menu item 11, modify and transform a copy of the original image file into a connect-the-dots-style image suitable for inclusion in a connect-the-dots activity book to execute for the follow-on workflows.
If, after the user checks this box and the user previously selected the “All” checkbox, then the application will automatically checkmark the “All” checkbox.
If the user unchecks this box and the user previously selected the “All” checkbox, then the application will automatically unselect the “All” checkbox.
Checkbox label = “BK_CTD” and the hover tooltip = “Connect-the-dots activity book.”
Checkbox 7 –
This checkbox designates that the user needs command-line-style Part 1 menu item 12, modify and transform a copy of the original image file into a color-by-numbers-style image suitable for inclusion in a color-by-numbers activity book to execute for the follow-on workflows.
If, after the user checks this box and the user previously selected the “All” checkbox, then the application will automatically checkmark the “All” checkbox.
If the user unchecks this box and the user previously selected the “All” checkbox, then the application will automatically unselect the “All” checkbox.
Checkbox label = “BK_CBN” and the hover tooltip = “Color-by-numbers activity book.”
Frame B, Row 2: A Windows Explorer-style, but bare bones, box/frame. This is a temporary drop zone where the user may optionally drag and drop files from the list in Frame A to this container. The application will process the files the user drops into this container per the checkboxes selected in Frame B, Row 1. The system will indicate busy/processing when that is the case by displaying a “busy” icon, prompt, or cursor. Upon processing completion, the application removes the dropped file(s) from this box and puts the processing-complete file(s) in the pickup zone box, see the following item, Frame B, Row 3. If the processing was a success, then a pop-up dialog stating such displays. If the processing was not a success, then a pop-up dialog stating such displays. Upon application startup, the application ensures that this container is empty. The default value for this container is blank/empty/null. If the user drops a file or files in this container but has not selected any checkboxes in Frame B, Row 1, then a validation warning message dialog pops up stating such and allowing the user to make corrections. When the user has not selected any of the checkboxes, this drop zone container is inactive and in a read-only state. If the user has dropped a file or files in this container, and the application is busy processing the file(s), then the checkboxes are temporarily read-only, and the user cannot change them.
Frame B, Row 3: A Windows Explorer-style, but bare bones, box/frame. This is a temporary pickup zone where the user may optionally collect and drag out files that the application has finished processing from above. The application will put files into this container post-processing per the checkboxes selected in Frame B, Row 1. While the application is open and running, the files will remain here and accumulate until the user drags them out of this container, and the container is empty again. Upon application startup, the application ensures that this container is empty. The default value for this container is blank/empty/null.
Frame B, Rows 4 – 8:
Each row has four (4) cells (i.e., columns)
The whole matrix is a 4-cell wide by 5-cell high, 20-cell matrix.
My intent for this matrix is to have cells that are drop zones for drag-and-drop functionality. 
Each column has a minimalistic column header cell/drop zone, which is little more than a placeholder.
Each row has a minimalistic row header cell/drop zone, which is little more than a placeholder. 
The remaining 3-cell wide by 4-cell high, 12-cell matrix consists of 12 Windows Explorer-style frames/containers. The user can find, select, drill down to navigate to, or paste a path to open a folder in each of the twelve primary cells. Each of the twelve primary cells/containers may be unique/distinct folders, or there may be duplicate folders selected across the twelve primary cells/containers.
The topmost, leftmost matrix corner is a table/matrix cell/drop zone, which is little more than a placeholder. 
The user may drop into any of these twelve primary cells, a column header, a row header, or any user-selected image file(s) that the user chooses at random.
If the user drops a file or files into any of the twelve primary cells, then the location/directory the user selected for a given cell is where the application puts the file(s).
If the user drops a file or files onto the column header placeholder, then the application puts the file(s) into all cells underneath that column header.
If the user drops a file or files onto the row header placeholder, then the application puts the file(s) into all the cells to the right and in the same row as the header.
If the user drops a file or files onto the table/matrix header placeholder, then the application puts the file(s) into all twelve primary cells.
If the user drags from Frame A directly, then this functionality is a file copy. If the user drags from Frame B, Row 3, the processed file pickup zone, then this functionality is a file move (from the pickup zone to the selected cell/container/folder.
For each of the twelve primary cells, the cell/frame/container header/title displays: a) the path, or as much as will fit, with precedence on the tail end or right-hand portion of the path. The user may optionally scroll to the left to see the remaining portion of the path; b) the total file count, the count of JPG/JPEG files, and the count of PNG files; and c) the Name column, only. The default sort is by Name, alphabetically and in ASC order. This is the only list sorting option available, and the user may reverse the sort order on demand.
Frame B, Row 4: Four (4) cells/placeholders/frames, height is 100% of the row height, width is the available width at 25% for each cell/placeholder.
Frame B, Row 5: Four (4) cells/placeholders/frames, height is 100% of the row height, width is the available width at 25% for each cell/placeholder.
Frame B, Row 6: Four (4) cells/placeholders/frames, height is 100% of the row height, width is the available width at 25% for each cell/placeholder.
Frame B, Row 7: Four (4) cells/placeholders/frames, height is 100% of the row height, width is the available width at 25% for each cell/placeholder.
Frame B, Row 8: Four (4) cells/placeholders/frames, height is 100% of the row height, width is the available width at 25% for each cell/placeholder.
Normal workflow #1: Begin. Open folder/directory location in Frame A, open folder(s)/directory(ies) in the 12 primary cells of the matrix in Frame B, locate file(s) in Frame A, drag files from Frame A to where the user needs them in the drop zone matrix in Frame B. The application executes a copy file function. End.
Normal workflow #2: Begin. Open folder/directory location in Frame A, open folder(s)/directory(ies) in the 12 primary cells of the matrix in Frame B, locate file(s) in Frame A, checkmark/select the functionality in Frame B, Row 1, checkbox list that the user needs the application to execute, drag files from Frame A to the processing drop zone in Frame B, Row 2, the application performs the processing selected by the user, the application puts the processed files in the pickup zone at Frame B, Row 3, the user drags the files from the pickup zone at Frame B, Row 3, to where the user needs them in the drop zone matrix in Frame B. The application executes a move file function from the pickup zone to the matrix. End.
Alternate and Exception workflows: I cannot think of any. You may make recommendations and suggestions if you have any.
This solution will, by default, exclude Hidden and System folders and files from scans. This solution will accommodate long path names, long folder names, and long file names. This solution will accommodate foreign languages, foreign typography, and foreign character sets.
The application performs memory management, memory cleanup, handle cleanup, garbage collection, and closing/releasing functions/functionality/methods/libraries after every copy or move command.
Before you begin, you need to analyze all these requirements and specifications and let me know if they are complete, concise, programmable, feasible, doable, unambiguous, consistent, self-consistent, in line with best practices, clear, and understandable. You need to let me know of any potential issues, gaps, missing pieces/parts, and any nice-to-haves. You need to create an implementation that is as cost-effective as possible, free is best, and low-cost is next best. I am willing to make compromises to include quality to keep the cost as low as possible. Processing resources and processing time are of little concern to me, although the maximum reasonable processing time is approximately two days for processing 27,000 images.
My current local device specifications:
Device name	PlatoPC
Processor	12th Gen Intel(R) Core (TM) i7-12650H (2.70 GHz)
Installed RAM	64.0 GB (63.7 GB usable)
System type: 64-bit operating system, x64-based processor
Edition	Windows 11 Pro
Version	25H2
OS build	26220.7070
Experience	Windows Feature Experience Pack 1000.26100.272.0
Microsoft Visual Studio Community 2022
Version 17.14.20
Visual Studio 17. Release / 17.14.20+36705.20
Microsoft .NET Framework
Version 4.8.09221
Installed Version: Community
Microsoft Visual Studio Code 2022
Version: 1.105.1 (system setup)
Electron: 37.6.0
Electron Build Id: 12502201
Chromium: 138.0.7204.251
Node.js: 22.19.0
V8: 13.8.258.32-electron.0
OS: Windows_NT x64 10.0.26220
You need to date-time-stamp all communications, deliverables, and artifacts.
I do not like patches, copy and paste, partial files, replacing lines of code line-by-line, searching for code inside of files, file downloads that fail, files that are empty, files, deliverables, and artifacts that revert to earlier versions with sufficient justification, and enhanced or improved files, deliverables, and artifacts that have smaller file sizes after enhancing them.
Please perform QA/QC tests and checks, sanity tests and checks, compare the file's current hash value with the previous file's hash value to confirm no duplicate file transfers, spell checking, grammar checking, syntax checking, and format/style checking on all deliverables and artifacts you send to me. Ensure you do not send me empty files. Ensure you do not send me files that are significantly smaller than previous versions/iterations. Do not artificially inflate file sizes to cheat on the last statement. When you send me deliverables and artifacts, along with the file download, please send me the file name and extension, the file size, and the file hash value. Confirm all files, deliverables, and artifacts you send to me do not have any variables that are never declared/initialized, do not have any variables that are never called/used, do not have any imports that are never utilized, do not have any functions or data for which an import is missing, do not have any function calls to functions that are never declared/defined, do not have any declared/defined tasks that are never called, do not have escape chars where they are not needed, do not have unnecessary/duplicate/extraneous escape chars, do not have quotes where they are not required, do not have unnecessary/duplicate/extraneous quotes, all comments begin with the comment reserved character, all literal strings are quoted, as needed, the proper entry points exist, the appropriate exit points exist, and everything that should provide a return value has a return line and is capable of providing an accurate value.
Ensure the application dedupes all data and deliverables, that the prose and text are in the correct case, and that the application implements and performs all spellchecking, grammar checking, and syntax checking.
Ensure all opening brackets, braces, and parentheses have appropriately placed closing brackets, braces, and parentheses. Ensure there are no extra/extraneous closing brackets, braces, and parentheses.
I prefer TOML-style config/settings files unless there is a reason for utilizing a different format.
I prefer the basic, bare minimum command line parameters necessary.
I prefer the files, deliverables, and artifacts you send to me to work out-of-the-box, execute, run, and function immediately after I download.
I prefer the maximum number of files I need to download at a time to be set to three. If there are more than three items for me to download, then I prefer all the files in a ZIP file.
All chats and conversations you will conduct in English.
All deliverables, artifacts, and files you will create/implement in Korean and English. You need to perform translations as required unless the line-item requirements and specifications call out an exception.
You need to review, assess, and evaluate all requirements and specifications, and let me know if you consider them clear, concise, unambiguous, testable, doable, feasible, in line with best practices, consistent, self-consistent, and understandable. You need to let me know if you detect any conflicts, gaps, missing pieces, or nice-to-haves. You need to report to me the quantity of sentences you detect, the quantity of requirements you detect, and the number of tokens you detect. You need to evaluate which AI model is best for this job/implementation, if you will be utilizing that model, and if not, why not, and which model you will be utilizing.


